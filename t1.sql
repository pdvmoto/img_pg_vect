
create table t1 ( 
  id        NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  v         vector ( 3, * ) -- FLOAT(64)[3] ?
);

delete from t1 ;

INSERT INTO t1 (v) VALUES ('[1.0, 1.0, 1.0]');
INSERT INTO t1 (v) VALUES ('[1.0, 1.0, 1.0]');
INSERT INTO t1 (v) VALUES ('[1.0, 2.0, 1.0]'); -- would be 1 away from nr2.
INSERT INTO t1 (v) VALUES ('[2.0, 2.0, 2.0]'); -- would be same cosdist as nr1.

select * 
from t1 order by id  ;

-- verify "distance" 
select t1.id, t2.id as id2 -- , t1.v, t2.v
, t1.v <=> t2.v         as cos_dist
, t1.v <-> t2.v         as eucl_dist 
, t1.v <#> t2.v         as inn_prod 
from t1 t1, t1 t2
where t1.id < t2.id
order by t1.id, t2.id; 


-- view to obtain varchar
create or replace view v1      as ( select id, ( from_vector ( v ))  as v_ser from t1    ); 

create or replace view v_split as ( 
select id
, replace ( replace ( from_vector ( v ), '[', '' ), ']', '' )  as v_ser 
from t1    
);

-- view to obtain splittable vc, and split..


-- demo to split..
with rws as (
     select ',leading,commas,and,trailing,' str from dual
  -- select from_vector ( v )  from t1 
)
  select regexp_substr (
           str,
           '[^,]+',
           1,
           level
         ) value
  from   rws
  connect by level <= 
    length ( trim ( both ',' from str ) ) - 
    length ( replace ( str, ',' ) ) + 1;

-- hand the string, with just the CSV-values, to the splitter
with rws as (
  -- select ',leading,commas,and,trailing,' str from dual
   select id, v_ser from v_split 
)
  select distinct /* i know, i know, distinct */
         id
       , level as elem_nr
       , regexp_substr (
           v_ser,
           '[^,]+',
           1,
           level
         ) vct_item_value
  from   rws
  connect by level <= 
    length ( trim ( both ',' from v_ser ) ) - 
    length ( replace ( v_ser, ',' ) ) + 1
  order by id, level ;

select * from v_split ;
